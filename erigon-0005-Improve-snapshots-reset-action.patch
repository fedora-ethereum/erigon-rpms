From: Matt Joiner <anacrolix@gmail.com>
Date: Mon, 25 Aug 2025 12:14:41 +1000
Subject: [PATCH] Improve snapshots reset action

- Handles missing or obsolete format chaindata (Fixes #16717 and https://discord.com/channels/1133875232453693480/1356926710502916096/1407195677930295348).
- Fixes double logging setup (observed on Discord a few times but I missed it).
- Correctly loads chain flag setup from parent CLI contexts.
- Requires datadir and chain to be set on parent context (proper urfave/cli@v2 behaviour).
- Logs datadir operated on (so default datadir action is clear).

diff --git a/.github/workflows/qa-tip-tracking.yml b/.github/workflows/qa-tip-tracking.yml
index b06eb72389..e9d024d407 100644
--- a/.github/workflows/qa-tip-tracking.yml
+++ b/.github/workflows/qa-tip-tracking.yml
@@ -199,7 +199,7 @@ jobs:
     - name: Run the datadir downgrade procedure
       working-directory: ${{ github.workspace }}
       run: |
-        ./build/bin/erigon seg reset-to-old-ver-format --datadir $ERIGON_TESTBED_DATA_DIR
+        ./build/bin/erigon --datadir $ERIGON_TESTBED_DATA_DIR snapshots reset-to-old-ver-format 
 
     - name: Print datadir contents after downgrade (for debugging)
       working-directory: ${{ github.workspace }}
diff --git a/erigon-lib/common/datadir/dirs.go b/erigon-lib/common/datadir/dirs.go
index b273512053..30e7057bec 100644
--- a/erigon-lib/common/datadir/dirs.go
+++ b/erigon-lib/common/datadir/dirs.go
@@ -320,7 +320,7 @@ func (d *Dirs) RenameOldVersions(cmdCommand bool) error {
 	}
 	if renamed > 0 || removed > 0 {
 		log.Warn("Your snapshots are compatible but old. We recommend you (for better experience) " +
-			"upgrade them by `./build/bin/erigon snapshots reset --datadir /your` command, after this command: next Erigon start - will download latest files (but re-use unchanged files) - likely will take many hours")
+			"upgrade them by `./build/bin/erigon --datadir /your/datadir snapshots reset ` command, after this command: next Erigon start - will download latest files (but re-use unchanged files) - likely will take many hours")
 	}
 	if d.Downloader != "" && (renamed > 0 || removed > 0) {
 		if err := dir.RemoveAll(d.Downloader); err != nil && !os.IsNotExist(err) {
diff --git a/erigon-lib/state/domain.go b/erigon-lib/state/domain.go
index 7869513a87..b60650f32a 100644
--- a/erigon-lib/state/domain.go
+++ b/erigon-lib/state/domain.go
@@ -2130,5 +2130,10 @@ func (dt *DomainRoTx) Name() kv.Domain { return dt.name }
 func (dt *DomainRoTx) HistoryProgress(tx kv.Tx) uint64 { return dt.ht.iit.Progress(tx) }
 
 func versionTooLowPanic(filename string, version version.Versions) {
-	panic(fmt.Sprintf("Version is too low, try to run snapshot reset: `erigon snapshots reset --datadir $DATADIR --chain $CHAIN`. file=%s, min_supported=%s, current=%s", filename, version.MinSupported, version.Current))
+	panic(fmt.Sprintf(
+		"Version is too low, try to run snapshot reset: `erigon --datadir $DATADIR --chain $CHAIN snapshots reset`. file=%s, min_supported=%s, current=%s",
+		filename,
+		version.MinSupported,
+		version.Current,
+	))
 }
diff --git a/turbo/app/reset-datadir.go b/turbo/app/reset-datadir.go
index 2469dbd6cb..14ec217f65 100644
--- a/turbo/app/reset-datadir.go
+++ b/turbo/app/reset-datadir.go
@@ -3,7 +3,6 @@ package app
 import (
 	"errors"
 	"fmt"
-	"github.com/erigontech/erigon-lib/common/dir"
 	"io/fs"
 	"os"
 	"path/filepath"
@@ -15,12 +14,12 @@ import (
 	"github.com/erigontech/erigon-lib/chain"
 	"github.com/erigontech/erigon-lib/chain/snapcfg"
 	"github.com/erigontech/erigon-lib/common/datadir"
+	"github.com/erigontech/erigon-lib/common/dir"
 	"github.com/erigontech/erigon-lib/kv"
 	"github.com/erigontech/erigon-lib/kv/mdbx"
 	"github.com/erigontech/erigon-lib/log/v3"
 	"github.com/erigontech/erigon/cmd/utils"
 	"github.com/erigontech/erigon/core"
-	"github.com/erigontech/erigon/turbo/debug"
 	"github.com/urfave/cli/v2"
 )
 
@@ -41,33 +40,47 @@ var (
 	}
 )
 
-func resetCliAction(cliCtx *cli.Context) (err error) {
-	// Set logging verbosity. Oof that function signature.
-	logger, _, _, _, err := debug.Setup(cliCtx, true)
-	if err != nil {
-		err = fmt.Errorf("setting up logging: %w", err)
-		return
+// Checks if a value was explicitly set in the given CLI command context or any of its parents. In
+// urfave/cli@v2, you must check the lineage to see if a flag was set in any context. It may be
+// different in v3.
+func isSetLineage(cliCtx *cli.Context, flagName string) bool {
+	for _, ctx := range cliCtx.Lineage() {
+		if ctx.IsSet(flagName) {
+			return true
+		}
 	}
+	return false
+}
+
+func resetCliAction(cliCtx *cli.Context) (err error) {
+	// This is set up in snapshots cli.Command.Before.
+	logger := log.Root()
 	removeLocal := removeLocalFlag.Get(cliCtx)
 	dryRun := dryRunFlag.Get(cliCtx)
 	dataDirPath := cliCtx.String(utils.DataDirFlag.Name)
+	logger.Info("resetting datadir", "path", dataDirPath)
 
 	dirs := datadir.Open(dataDirPath)
 
 	configChainName, chainNameErr := getChainNameFromChainData(cliCtx, logger, dirs.Chaindata)
 
 	chainName := utils.ChainFlag.Get(cliCtx)
-	if cliCtx.IsSet(utils.ChainFlag.Name) {
+	// Check the lineage, we don't want to use the mainnet default, but due to how urfave/cli@v2
+	// works we shouldn't randomly re-add the chain flag in the current command context.
+	if isSetLineage(cliCtx, utils.ChainFlag.Name) {
 		if configChainName.Ok && configChainName.Value != chainName {
 			// Pedantic but interesting.
 			logger.Warn("chain name flag and chain config do not match", "flag", chainName, "config", configChainName.Value)
 		}
 		logger.Info("using chain name from flag", "chain", chainName)
-	} else if chainNameErr != nil {
-		return fmt.Errorf("getting chain name from chaindata: %w", chainNameErr)
-	} else if !configChainName.Ok {
-		return errors.New("chain flag not set and chain name not found in chaindata (reset already occurred or invalid data dir?)")
 	} else {
+		if chainNameErr != nil {
+			logger.Warn("error getting chain name from chaindata", "err", chainNameErr)
+		}
+		if !configChainName.Ok {
+			return errors.New(
+				"chain flag not set and chain name not found in chaindata. datadir is ready for sync, invalid, or requires chain flag to reset")
+		}
 		chainName = configChainName.Unwrap()
 		logger.Info("read chain name from config", "chain", chainName)
 	}
@@ -152,6 +165,10 @@ func resetCliAction(cliCtx *cli.Context) (err error) {
 }
 
 func getChainNameFromChainData(cliCtx *cli.Context, logger log.Logger, chainDataDir string) (_ g.Option[string], err error) {
+	_, err = os.Stat(chainDataDir)
+	if err != nil {
+		return
+	}
 	ctx := cliCtx.Context
 	var db kv.RoDB
 	db, err = mdbx.New(kv.ChainDB, logger).Path(chainDataDir).Accede(true).Readonly(true).Open(ctx)
diff --git a/turbo/app/snapshots_cmd.go b/turbo/app/snapshots_cmd.go
index 78f51820e2..418f74e4e1 100644
--- a/turbo/app/snapshots_cmd.go
+++ b/turbo/app/snapshots_cmd.go
@@ -278,14 +278,13 @@ var snapshotCommand = cli.Command{
 			Name:   "reset",
 			Usage:  "Reset state to resumable initial sync",
 			Action: resetCliAction,
-			// Something to alter snapcfg.snapshotGitBranch would go here, or should you set the environment variable?
-			Flags: append(
-				slices.Clone(logging.Flags),
-				&utils.DataDirFlag,
-				&utils.ChainFlag,
+			// Something to alter snapcfg.snapshotGitBranch would go here, or should you set the
+			// environment variable? Followup: It would not go here, as it could modify behaviour in
+			// parent commands.
+			Flags: []cli.Flag{
 				&dryRunFlag,
 				&removeLocalFlag,
-			),
+			},
 		},
 		{
 			Name:    "rm-state-snapshots",
